[["step-by-step-scrna-seq-pipeline.html", "4 Step-by-step scRNA-seq Pipeline 4.1 Before you begin 4.2 Step 1. Load the input data 4.3 Step 2. Quality Control 4.4 Step 3. Clustering 4.5 Step 4. Identify Cell Types 4.6 Step 5. Visualization 4.7 Step 6. Find DEGs 4.8 Step 7. Assign Cell Cycles 4.9 Step 8. Calculate Heterogeneity 4.10 Step 9. Violin Plot for Marker Genes 4.11 Step 10. Calculate Lineage Scores 4.12 Step 11. GSVA 4.13 Step 12. Construct Trajectories 4.14 Step 13. TF Analysis 4.15 Step 14. Cell-Cell Interaction", " 4 Step-by-step scRNA-seq Pipeline 4.1 Before you begin Load the R packages. library(Seurat) library(phateR) library(DoubletFinder) library(monocle) library(slingshot) library(URD) library(GSVA) library(limma) library(plyr) library(dplyr) library(org.Mm.eg.db) library(org.Hs.eg.db) library(CellChat) library(velocyto.R) library(SeuratWrappers) library(stringr) library(scran) library(ggpubr) library(viridis) library(pheatmap) library(parallel) library(reticulate) library(SCENIC) library(feather) library(AUCell) library(RcisTarget) library(Matrix) library(foreach) library(doParallel) library(clusterProfiler) library(OpenXGR) library(RColorBrewer) library(Rfast2) library(SeuratDisk) library(abcCellmap) library(biomaRt) library(copykat) library(gelnet) library(ggplot2) library(parallelDist) library(patchwork) library(markdown) library(getopt) library(tools) library(HemaScopeR) Set the paths for the output results, and the Python installation. output.dir = &#39;./output&#39; pythonPath = &#39;/home/anaconda3/envs/HemaScopeR/bin/python&#39; Create folders for saving the results of HemaScopeR analysis. wdir &lt;- getwd() if(is.null(pythonPath)==FALSE){ reticulate::use_python(pythonPath) }else{print(&#39;Please set the path of Python.&#39;)} if (!file.exists(paste0(output.dir, &#39;/HemaScopeR_results&#39;))) { dir.create(paste0(output.dir, &#39;/HemaScopeR_results&#39;),recursive =T) } output.dir &lt;- paste0(output.dir,&#39;/HemaScopeR_results&#39;) if (!file.exists(paste0(output.dir, &#39;/RDSfiles/&#39;))) { dir.create(paste0(output.dir, &#39;/RDSfiles/&#39;)) } #set the path for loading previous results, if necessary previous_results_path &lt;- paste0(output.dir, &#39;/RDSfiles/&#39;) # if (Whether_load_previous_results) { # print(&#39;Loading the previous results...&#39;) # Load_previous_results(previous_results_path = previous_results_path) # } 4.2 Step 1. Load the input data Create a folder for step1 print(&#39;Step1. Input data.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step1.Input_data/&#39;))) { dir.create(paste0(output.dir, &#39;/Step1.Input_data/&#39;)) } Set the parameters for loading the data sets. input.data.dirs = c(&#39;./SRR7881399/outs/filtered_feature_bc_matrix&#39;)#, #&#39;./SRR7881400/outs/filtered_feature_bc_matrix&#39;, #&#39;./SRR7881401/outs/filtered_feature_bc_matrix&#39;, #&#39;./SRR7881402/outs/filtered_feature_bc_matrix&#39;, #&#39;./SRR7881403/outs/filtered_feature_bc_matrix&#39; project.names = c(&#39;SRR7881399&#39;)#, #&#39;SRR7881400&#39;, #&#39;SRR7881401&#39;, #&#39;SRR7881402&#39;, #&#39;SRR7881403&#39; gene.column = 2 min.cells = 10 min.feature = 200 mt.pattern = &#39;^MT-&#39; # set &#39;^mt-&#39; for mouse data Step1_Input_Data.type = &#39;cellranger-count&#39; loom.files.path =&quot;./SRR7881399/loom&quot; Load the data sets file.copy(from = input.data.dirs, to = paste0(output.dir,&#39;/Step1.Input_data/&#39;), recursive = TRUE) if(Step1_Input_Data.type == &#39;cellranger-count&#39;){ if(length(input.data.dirs) &gt; 1){ input.data.list &lt;- c() for (i in 1:length(input.data.dirs)) { sc_data.temp &lt;- Read10X(data.dir = input.data.dirs[i], gene.column = gene.column) sc_object.temp &lt;- CreateSeuratObject(counts = sc_data.temp, project = project.names[i], min.cells = min.cells, min.feature = min.feature) sc_object.temp[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(sc_object.temp, pattern = mt.pattern) input.data.list &lt;- c(input.data.list, sc_object.temp)} }else{ sc_data &lt;- Read10X(data.dir = input.data.dirs, gene.column = gene.column) sc_object &lt;- CreateSeuratObject(counts = sc_data, project = project.names, min.cells = min.cells, min.feature = min.feature) sc_object[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(sc_object, pattern = mt.pattern) } }else if(Step1_Input_Data.type == &#39;Seurat&#39;){ if(length(input.data.dirs) &gt; 1){ input.data.list &lt;- c() for (i in 1:length(input.data.dirs)) { sc_object.temp &lt;- readRDS(input.data.dirs[i]) sc_object.temp[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(sc_object.temp, pattern = mt.pattern) input.data.list &lt;- c(input.data.list, sc_object.temp) } }else{ sc_object &lt;- readRDS(input.data.dirs) sc_object[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(sc_object, pattern = mt.pattern) } }else if(Step1_Input_Data.type == &#39;Matrix&#39;){ if(length(input.data.dirs) &gt; 1){ input.data.list &lt;- c() for (i in 1:length(input.data.dirs)) { sc_data.temp &lt;- readRDS(input.data.dirs[i]) sc_object.temp &lt;- CreateSeuratObject(counts = sc_data.temp, project = project.names[i], min.cells = min.cells, min.feature = min.feature) sc_object.temp[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(sc_object.temp, pattern = mt.pattern) input.data.list &lt;- c(input.data.list, sc_object.temp)} }else{ sc_data &lt;- readRDS(input.data.dirs) sc_object &lt;- CreateSeuratObject(counts = sc_data, project = project.names, min.cells = min.cells, min.feature = min.feature) sc_object[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(sc_object, pattern = mt.pattern) } }else{ stop(&#39;Please input data generated by the cellranger-count software, or a Seurat object, or a gene expression matrix. HemaScopeR does not support other formats of input data.&#39;) } Save the variables after executing each step, if necessary. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } 4.3 Step 2. Quality Control In this step, the following quality control steps will be performed: Normalize data using the LogNormalize method. Find variable features using the vst method. Scale data using the identified variable features and specified variables to regress out. Perform principal component analysis (PCA) on the scaled data. Find K nearest neighbors based on PCA dimensions. Perform clustering analysis based on the found neighbors. Optionally, remove doublets using doubletFinder. Optionally, integrate multiple datasets by removing batch effects. 4.3.1 Function arguments: nFeature_RNA.limit: The cutoff of the minimum number of detected genes in each cell. percent.mt.limit: The cutoff of the maximum percentage of mitochondria genes in each cell. scale.factor: The scale factor for the ‘data’ slot in the seurat object. nfeatures: The number of selected highly variable features for down stream analysis. ndims: The number of principle components in PCA. vars.to.regress: Variables to regress out (previously latent.vars in RegressOut). For example, nUMI, or percent.mito. (ScaleData in Seurat) PCs: Which dimensions to use as input features.(RunTSNE and RunUMAP in Seurat) resolution: Value of the resolution parameter, use a value above (below) 1.0 if you want to obtain a larger (smaller) number of communities. (FindClusters in Seurat) n.neighbors: Defines k for the k-nearest neighbor algorithm. (FindNeighbors in Seurat) percentage: Assuming ‘percentage’ doublet formation rate - tailor for your dataset. The default value is 0.05. doublerFinderwraper.PCs Which dimensions to use as input features for doubletFinder. doublerFinderwraper.pN: The percentage of real-artifical data for doubletFinder. doublerFinderwraper.pK: The pK parameter controls the doublet cell detection by determining the number of nearest neighbors and influencing the calculation of pANN scores and the final cell classification results. Adjusting the pK value allows optimization of the doublet cell detection process based on specific data and analysis requirements. 4.3.2 codes for running step2 Create a folder for saving the results of quality control. print(&#39;Step2. Quality control.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step2.Quality_control/&#39;))) { dir.create(paste0(output.dir, &#39;/Step2.Quality_control/&#39;)) } Set the parameters for quality control. # quality control nFeature_RNA.limit = 200 percent.mt.limit = 20 # preprocessing nfeatures = 3000 scale.factor = 10000 ndims = 50 vars.to.regress = NULL PCs = 1:35 resolution = 0.4 n.neighbors = 50 # removing doublets Step2_Quality_Control.RemoveDoublets = TRUE doublet.percentage = 0.04 doublerFinderwraper.PCs = 1:20 doublerFinderwraper.pN = 0.25 doublerFinderwraper.pK = 0.1 # removing batch effect Step2_Quality_Control.RemoveBatches = TRUE Run the quality control process. if(length(input.data.dirs) &gt; 1){ # preprocess and quality control for multiple scRNA-Seq data sets sc_object &lt;- QC_multiple_scRNASeq(seuratObjects = input.data.list, datasetID = project.names, output.dir = paste0(output.dir,&#39;/Step2.Quality_control/&#39;), Step2_Quality_Control.RemoveBatches = Step2_Quality_Control.RemoveBatches, Step2_Quality_Control.RemoveDoublets = Step2_Quality_Control.RemoveDoublets, nFeature_RNA.limit = nFeature_RNA.limit, percent.mt.limit = percent.mt.limit, scale.factor = scale.factor, nfeatures = nfeatures, ndims = ndims, vars.to.regress = vars.to.regress, PCs = PCs, resolution = resolution, n.neighbors = n.neighbors, percentage = doublet.percentage, doublerFinderwraper.PCs = doublerFinderwraper.PCs, doublerFinderwraper.pN = doublerFinderwraper.pN, doublerFinderwraper.pK = doublerFinderwraper.pK ) }else{ # preprocess and quality control for single scRNA-Seq data set sc_object &lt;- QC_single_scRNASeq(sc_object = sc_object, datasetID = project.names, output.dir = paste0(output.dir,&#39;/Step2.Quality_control/&#39;), Step2_Quality_Control.RemoveDoublets = Step2_Quality_Control.RemoveDoublets, nFeature_RNA.limit = nFeature_RNA.limit, percent.mt.limit = percent.mt.limit, scale.factor = scale.factor, nfeatures = nfeatures, vars.to.regress = vars.to.regress, ndims = ndims, PCs = PCs, resolution = resolution, n.neighbors = n.neighbors, percentage = doublet.percentage, doublerFinderwraper.PCs = doublerFinderwraper.PCs, doublerFinderwraper.pN = doublerFinderwraper.pN, doublerFinderwraper.pK = doublerFinderwraper.pK) } Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } 4.3.3 Outputs Figure 4.1: Violin plots showing the nFeature, nCount and percent.mt for each sample Figure 4.2: Figures showing the correlation between nFeature and nCount, as well as between nCount and percent.mt Figure 4.3: Figures showing the variable features used for downstream analysis Figure 4.4: ElbowPlot showing suitable number of PCs used for further analysis Figure 4.5: UMAP plot showing doublets found by DoubletFinder 4.4 Step 3. Clustering Create a folder for saving the results of Louvain clustering. print(&#39;Step3. Clustering.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step3.Clustering/&#39;))) { dir.create(paste0(output.dir, &#39;/Step3.Clustering/&#39;)) } Set the parameters for clustering. PCs = 1:35 resolution = 0.4 n.neighbors = 50 Run Louvian clustering. if( (length(input.data.dirs) &gt; 1) &amp; Step2_Quality_Control.RemoveBatches ){graph.name &lt;- &#39;integrated_snn&#39;}else{graph.name &lt;- &#39;RNA_snn&#39;} sc_object &lt;- FindNeighbors(sc_object, dims = PCs, k.param = n.neighbors, force.recalc = TRUE) sc_object &lt;- FindClusters(sc_object, resolution = resolution, graph.name = graph.name) sc_object@meta.data$seurat_clusters &lt;- as.character(as.numeric(sc_object@meta.data$seurat_clusters)) # plot clustering pdf(paste0(paste0(output.dir,&#39;/Step3.Clustering/&#39;), &#39;/sc_object &#39;,&#39;tsne_cluster.pdf&#39;), width = 6, height = 6) print(DimPlot(sc_object, reduction = &quot;tsne&quot;, group.by = &quot;seurat_clusters&quot;, label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() pdf(paste0(paste0(output.dir,&#39;/Step3.Clustering/&#39;), &#39;/sc_object &#39;,&#39;umap_cluster.pdf&#39;), width = 6, height = 6) print(DimPlot(sc_object, reduction = &quot;umap&quot;, group.by = &quot;seurat_clusters&quot;, label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() png(paste0(paste0(output.dir,&#39;/Step3.Clustering/&#39;), &#39;/sc_object &#39;,&#39;tsne_cluster.png&#39;), width = 600, height = 600) print(DimPlot(sc_object, reduction = &quot;tsne&quot;, group.by = &quot;seurat_clusters&quot;, label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() png(paste0(paste0(output.dir,&#39;/Step3.Clustering/&#39;), &#39;/sc_object &#39;,&#39;umap_cluster.png&#39;), width = 600, height = 600) print(DimPlot(sc_object, reduction = &quot;umap&quot;, group.by = &quot;seurat_clusters&quot;, label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } Figure 4.6: UMAP plot showing clustering results 4.5 Step 4. Identify Cell Types In this step, users can predict the cell types of hematopoietic cells by implementing two approaches (Scmap and Seurat) through abcCellmap packages. Cells are labeled by 43 different RNA clusters according to unsupervised clustering of single-cell transcriptional profiles, and also labeled by 32 immunophenotypic cell types. In addition, users can use Copykat to measure copy number variation (CNV) and determine the ploidy of each cell. 4.5.1 codes for running abcCellmap Create a folder for saving the results of cell type identification. print(&#39;Step4. Identify cell types automatically.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step4.Identify_Cell_Types/&#39;))) { dir.create(paste0(output.dir, &#39;/Step4.Identify_Cell_Types/&#39;)) } Set the path for the database. databasePath = &quot;~/HemaScopeR/database/&quot; Set the parameters for cell type identification. Step4_Use_Which_Labels = &#39;clustering&#39; Step4_Cluster_Labels = NULL Step4_Changed_Labels = NULL Org = &#39;hsa&#39; ncores = 10 Run the cell type identification process. sc_object &lt;- run_cell_annotation(object = sc_object, assay = &#39;RNA&#39;, species = Org, output.dir = paste0(output.dir,&#39;/Step4.Identify_Cell_Types/&#39;)) if(Org == &#39;hsa&#39;){ load(paste0(databasePath,&quot;/HematoMap.reference.rdata&quot;)) #the data can be downloaded via the link https://cloud.tsinghua.edu.cn/d/759fd04333274d3f9946 if(length(intersect(rownames(HematoMap.reference), rownames(sc_object))) &lt; 1000){ HematoMap.reference &lt;- RenameGenesSeurat(obj = HematoMap.reference, newnames = toupper(rownames(HematoMap.reference)), gene.use = rownames(HematoMap.reference), de.assay = &quot;RNA&quot;, lassays = &quot;RNA&quot;) } if(sc_object@active.assay == &#39;integrated&#39;){ DefaultAssay(sc_object) &lt;- &#39;RNA&#39; sc_object &lt;- mapDataToRef(ref_object = HematoMap.reference, ref_labels = HematoMap.reference@meta.data$CellType, query_object = sc_object, PCs = PCs, output.dir = paste0(output.dir, &#39;/Step4.Identify_Cell_Types/&#39;)) DefaultAssay(sc_object) &lt;- &#39;integrated&#39; }else{ sc_object &lt;- mapDataToRef(ref_object = HematoMap.reference, ref_labels = HematoMap.reference@meta.data$CellType, query_object = sc_object, PCs = PCs, output.dir = paste0(output.dir, &#39;/Step4.Identify_Cell_Types/&#39;)) } } Set the cell labels. # set the cell labels if(Step4_Use_Which_Labels == &#39;clustering&#39;){ sc_object@meta.data$selectLabels &lt;- sc_object@meta.data$seurat_clusters Idents(sc_object) &lt;- sc_object@meta.data$selectLabels }else if(Step4_Use_Which_Labels == &#39;abcCellmap.1&#39;){ sc_object@meta.data$selectLabels &lt;- sc_object@meta.data$Seurat.RNACluster Idents(sc_object) &lt;- sc_object@meta.data$selectLabels }else if(Step4_Use_Which_Labels == &#39;abcCellmap.2&#39;){ sc_object@meta.data$selectLabels &lt;- sc_object@meta.data$scmap.RNACluster Idents(sc_object) &lt;- sc_object@meta.data$selectLabels }else if(Step4_Use_Which_Labels == &#39;abcCellmap.3&#39;){ sc_object@meta.data$selectLabels &lt;- sc_object@meta.data$Seurat.Immunophenotype Idents(sc_object) &lt;- sc_object@meta.data$selectLabels }else if(Step4_Use_Which_Labels == &#39;abcCellmap.4&#39;){ sc_object@meta.data$selectLabels &lt;- sc_object@meta.data$scmap.Immunophenotype Idents(sc_object) &lt;- sc_object@meta.data$selectLabels }else if(Step4_Use_Which_Labels == &#39;HematoMap&#39;){ if(Org == &#39;hsa&#39;){ sc_object@meta.data$selectLabels &lt;- sc_object@meta.data$predicted.id Idents(sc_object) &lt;- sc_object@meta.data$selectLabels }else{print(&quot;&#39;HematoMap&#39; is only applicable to human data (&#39;Org&#39; = &#39;hsa&#39;).&quot;)} }else if(Step4_Use_Which_Labels == &#39;changeLabels&#39;){ if (!is.null(Step4_Cluster_Labels) &amp;&amp; !is.null(Step4_Changed_Labels) &amp;&amp; length(Step4_Cluster_Labels) == length(Step4_Changed_Labels)){ sc_object@meta.data$selectLabels &lt;- plyr::mapvalues(sc_object@meta.data$seurat_clusters, from = as.character(Step4_Cluster_Labels), to = as.character(Step4_Changed_Labels), warn_missing = FALSE) Idents(sc_object) &lt;- sc_object@meta.data$selectLabels }else{ print(&quot;Please input the &#39;Step4_Cluster_Labels&#39; parameter as Seurat clustering labels, and the &#39;Step4_Changed_Labels&#39; parameter as new labels. Please note that these two parameters should be of equal length.&quot;) } }else{ print(&#39;Please set the &quot;Step4_Use_Which_Labels&quot; parameter as &quot;clustering&quot;, &quot;abcCellmap.1&quot;, &quot;abcCellmap.2&quot;, &quot;HematoMap&quot; or &quot;changeLabels&quot;.&#39;) } Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } Figure 4.7: UMAP plots showing cell type annotation results Figure 4.8: Immunophenotype and RNACluster label predicted by scmap Figure 4.9: Immunophenotype and RNACluster label predicted by Seurat 4.5.2 codes for running the CNV analysis sc_CNV(sc_object=sc_object, save_path=paste0(output.dir,&#39;/Step4.Identify_Cell_Types/&#39;), assay = &#39;RNA&#39;, LOW.DR = 0.05, #refer to the Copykat documentation for detailed explanations of the parameters UP.DR = 0.1, win.size = 25, distance = &quot;euclidean&quot;, genome = NULL, n.cores = ncores, #note: this step will take a long time, using more ncores could shorten the running time species = Org) Figure 4.10: copykat heatmap Figure 4.11: UMAP plot showing CNV state predicted by copykat 4.6 Step 5. Visualization In this step, users are allowed to gain the statistical results about the numbers and proportions of cell groups, and also use three dimensional reduction methods (TSNE, UMAP, phateR) to visualize the results. 4.6.1 codes for peforming three dimensional reduction methods Create a folder for saving the visualization results. print(&#39;Step5. Visualization.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step5.Visualization/&#39;))) { dir.create(paste0(output.dir, &#39;/Step5.Visualization/&#39;)) } Perform visualization using UMAP and TSNE. # plot cell types pdf(paste0(paste0(output.dir,&#39;/Step5.Visualization/&#39;), &#39;/sc_object &#39;,&#39;tsne cell types.pdf&#39;), width = 6, height = 6) print(DimPlot(sc_object, reduction = &quot;tsne&quot;, group.by = &quot;ident&quot;, label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() pdf(paste0(paste0(output.dir,&#39;/Step5.Visualization/&#39;), &#39;/sc_object &#39;,&#39;umap cell types.pdf&#39;), width = 6, height = 6) print(DimPlot(sc_object, reduction = &quot;umap&quot;, group.by = &quot;ident&quot;, label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() png(paste0(paste0(output.dir,&#39;/Step5.Visualization/&#39;), &#39;/sc_object &#39;,&#39;tsne cell types.png&#39;), width = 600, height = 600) print(DimPlot(sc_object, reduction = &quot;tsne&quot;, group.by = &quot;ident&quot;, label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() png(paste0(paste0(output.dir,&#39;/Step5.Visualization/&#39;), &#39;/sc_object &#39;,&#39;umap cell types.png&#39;), width = 600, height = 600) print(DimPlot(sc_object, reduction = &quot;umap&quot;, group.by = &quot;ident&quot;, label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() Figure 4.12: UMAP and TSNE visualization Set the parameters for phateR. phate.knn = 50 #The number of nearest neighbors to consider in the phateR algorithm. Default 50. phate.npca = 20 #The number of principal components to use in the phateR algorithm. Default 20. phate.t = 10 #The t-value for the phateR algorithm, which controls the level of exploration. Default 10. phate.ndim = 2 #The number of dimensions for the output embedding in the phateR algorithm. Default 2. Run phateR for dimensional reduction and visualization. # run phateR if( (length(input.data.dirs) &gt; 1) &amp; Step2_Quality_Control.RemoveBatches ){ DefaultAssay(sc_object) &lt;- &#39;integrated&#39; }else{ DefaultAssay(sc_object) &lt;- &#39;RNA&#39;} if(!is.null(pythonPath)){ run_phateR(sc_object = sc_object, output.dir = paste0(output.dir,&#39;/Step5.Visualization/&#39;), pythonPath = pythonPath, phate.knn = phate.knn, phate.npca = phate.npca, phate.t = phate.t, phate.ndim = phate.ndim) } Figure 4.13: phateR result 4.6.2 codes for calculating the proportions The statistical results for the numbers and proportions of cell groups. # statistical results cells_labels &lt;- as.data.frame(cbind(rownames(sc_object@meta.data), as.character(sc_object@meta.data$selectLabels))) colnames(cells_labels) &lt;- c(&#39;cell_id&#39;, &#39;cluster_id&#39;) cluster_counts &lt;- cells_labels %&gt;% group_by(cluster_id) %&gt;% summarise(count = n()) total_cells &lt;- nrow(cells_labels) cluster_counts &lt;- cluster_counts %&gt;% mutate(proportion = count / total_cells) cluster_counts &lt;- as.data.frame(cluster_counts) cluster_counts$percentages &lt;- scales::percent(cluster_counts$proportion, accuracy = 0.1) cluster_counts &lt;- cluster_counts[,-which(colnames(cluster_counts)==&#39;proportion&#39;)] cluster_counts$cluster_id_count_percentages &lt;- paste(cluster_counts$cluster_id, &quot; (&quot;, cluster_counts$count, &#39; cells; &#39;, cluster_counts$percentages, &quot;)&quot;, sep=&#39;&#39;) cluster_counts &lt;- cluster_counts[order(cluster_counts$count, decreasing = TRUE),] cluster_counts &lt;- rbind(cluster_counts, c(&#39;Total&#39;, sum(cluster_counts$count), &#39;100%&#39;, &#39;all cells&#39;)) sc_object@meta.data$cluster_id_count_percentages &lt;- mapvalues(sc_object@meta.data$selectLabels, from=cluster_counts$cluster_id, to=cluster_counts$cluster_id_count_percentages, warn_missing=FALSE) colnames(sc_object@meta.data)[which(colnames(sc_object@meta.data) == &#39;cluster_id_count_percentages&#39;)] &lt;- paste(&#39;Total &#39;, nrow(sc_object@meta.data), &#39; cells&#39;, sep=&#39;&#39;) cluster_counts &lt;- cluster_counts[,-which(colnames(cluster_counts)==&#39;cluster_id_count_percentages&#39;)] colnames(cluster_counts) &lt;- c(&#39;Cell types&#39;, &#39;Cell counts&#39;, &#39;Percentages&#39;) # names(colorvector) &lt;- mapvalues(names(colorvector), # from=cluster_counts$cluster_id, # to=cluster_counts$cluster_id_count_percentages, # warn_missing=FALSE) write.csv(cluster_counts, file=paste(paste0(output.dir, &#39;/Step5.Visualization/&#39;), &#39;/cell types_cell counts_percentages.csv&#39;, sep=&#39;&#39;), quote=FALSE, row.names=FALSE) The UMAP visualization. pdf(paste(paste0(output.dir, &#39;/Step5.Visualization&#39;), &#39;/cell types_cell counts_percentages_umap.pdf&#39;, sep=&#39;&#39;), width = 14, height = 6) print(DimPlot(sc_object, reduction = &quot;umap&quot;, group.by = paste(&#39;Total &#39;, nrow(sc_object@meta.data), &#39; cells&#39;, sep=&#39;&#39;), label = FALSE, pt.size = 0.1, raster = FALSE)) dev.off() Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } Figure 4.14: UMAP plot showing cell type and corresponding proportion 4.7 Step 6. Find DEGs In this step, users can find DEGs (differentially expressed genes) across different cell type group using FindAllMarkers, use GPTCelltype to predict cell label, perform GO and KEGG enrichment analysis, and perform subnetwork analysis for each cell type group. 4.7.1 codes for finding DEGs Set the parameters for identifying differentially expressed genes. min.pct = 0.25 logfc.threshold = 0.25 Create a folder for the DEGs analysis. print(&#39;Step6. Find DEGs.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step6.Find_DEGs/&#39;))) { dir.create(paste0(output.dir, &#39;/Step6.Find_DEGs/&#39;)) } Identify DEGs using Wilcoxon Rank-Sum Test. sc_object.markers &lt;- FindAllMarkers(sc_object, only.pos = TRUE, min.pct = min.pct, logfc.threshold = logfc.threshold) write.csv(sc_object.markers, file = paste0(paste0(output.dir, &#39;/Step6.Find_DEGs/&#39;),&#39;sc_object.markerGenes.csv&#39;), quote=FALSE) # visualization sc_object.markers.top5 &lt;- sc_object.markers %&gt;% group_by(cluster) %&gt;% top_n(n = 5, wt = avg_log2FC) pdf(paste0(paste0(output.dir, &#39;/Step6.Find_DEGs/&#39;), &#39;sc_object_markerGenesTop5.pdf&#39;), width = 0.5*length(unique(sc_object.markers.top5$gene)), height = 0.5*length(unique(Idents(sc_object)))) print(DotPlot(sc_object, features = unique(sc_object.markers.top5$gene), cols=c(&quot;lightgrey&quot;,&#39;red&#39;))+theme(axis.text.x =element_text(angle = 45, vjust = 1, hjust = 1))) dev.off() png(paste0(paste0(output.dir, &#39;/Step6.Find_DEGs/&#39;), &#39;sc_object_markerGenesTop5.png&#39;), width = 20*length(unique(sc_object.markers.top5$gene)), height = 30*length(unique(Idents(sc_object)))) print(DotPlot(sc_object, features = unique(sc_object.markers.top5$gene), cols=c(&quot;lightgrey&quot;,&#39;red&#39;))+theme(axis.text.x =element_text(angle = 45, vjust = 1, hjust = 1))) dev.off() Figure 4.15: Dotplot showing marker genes of each cell type group 4.7.2 codes for using GPTCelltype Set the parameters for GPTCelltype. your_openai_API_key = &#39;&#39; tissuename = &#39;human bone marrow&#39; gptmodel = &#39;gpt-3.5&#39; Use GPTCelltype to assist cell type annotation. GPT_annotation( marker.genes = sc_object.markers, your_openai_API_key = your_openai_API_key, tissuename = tissuename, gptmodel = gptmodel, output.dir = paste0(output.dir, &#39;/Step6.Find_DEGs/&#39;)) 4.7.3 Perform GO and KEGG enrichment. # GO enrichment if(Org==&#39;mmu&#39;){ OrgDb &lt;- &#39;org.Mm.eg.db&#39; }else if(Org==&#39;hsa&#39;){ OrgDb &lt;- &#39;org.Hs.eg.db&#39; }else{ stop(&quot;Org should be &#39;mmu&#39; or &#39;hsa&#39;.&quot;) } HemaScopeREnrichment(DEGs=sc_object.markers, OrgDb=OrgDb, output.dir=paste0(output.dir, &#39;/Step6.Find_DEGs/&#39;)) Figure 4.16: Barplot showing GO（BP）and KEGG enrichment results of each cell type group 4.7.4 Perform subnetwork analysis Create a folder for saving the results of gene network analysis. if (!file.exists(paste0(output.dir, &#39;/Step6.Find_DEGs/OpenXGR/&#39;))) { dir.create(paste0(output.dir, &#39;/Step6.Find_DEGs/OpenXGR/&#39;)) } Perform gene network analysis. OpenXGR_SAG(sc_object.markers = sc_object.markers, output.dir = paste0(output.dir, &#39;/Step6.Find_DEGs/OpenXGR/&#39;), subnet.size = 10) Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } Figure 4.17: Figure showing subnetwork of each cell type group identified by OpenXGR 4.8 Step 7. Assign Cell Cycles This step assigns cell cycle phases by analyzing cell cycle-related genes and generates plots of the cell cycle analysis results. 4.8.1 Function arguments: sc_object: A Seurat object containing single-cell RNA sequencing data. counts_matrix: The ‘counts’ slot in the Seurat object. data_matrix: The ‘data’ slot in the Seurat object. cellcycleCutoff: The cutoff value for distinguishing between cycling and quiescent cells. Cells with a G1G2Score below this cutoff are considered quiescent. cellTypeOrders: The order of cell types for visualization. If not provided, the function will use the unique cell types in the input Seurat object. databasePath: The path to the database required for the analysis. Org: A character vector specifying the species of cell cycle genes, can be ‘mmu’ (mouse) or ‘hsa’ (human). 4.8.2 codes for step7 Create a folder for saving the results of cell cycle analysis. print(&#39;Step7. Assign cell cycles.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step7.Assign_cell_cycles/&#39;))) { dir.create(paste0(output.dir, &#39;/Step7.Assign_cell_cycles/&#39;)) } Set the parameters for the cell cycle analysis. cellcycleCutoff = NULL Run the cell cycle analysis. datasets.before.batch.removal &lt;- readRDS(paste0(paste0(output.dir, &#39;/RDSfiles/&#39;),&#39;datasets.before.batch.removal.rds&#39;)) sc_object &lt;- cellCycle(sc_object=sc_object, counts_matrix = GetAssayData(object = datasets.before.batch.removal, slot = &quot;counts&quot;)%&gt;%as.matrix(), data_matrix = GetAssayData(object = datasets.before.batch.removal, slot = &quot;data&quot;)%&gt;%as.matrix(), cellcycleCutoff = cellcycleCutoff, cellTypeOrders = unique(sc_object@meta.data$selectLabels), output.dir=paste0(output.dir, &#39;/Step7.Assign_cell_cycles/&#39;), databasePath = databasePath, Org = Org) Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } 4.8.3 Outputs Figure 4.18: Barplot showing the proportion of different cell cycle within each cell type group Figure 4.19: Density plot showing the distribution of cell cycle scores 4.9 Step 8. Calculate Heterogeneity This step quantifies cell heterogeneity by computing Spearman correlation coefficients between cells within the same cell type groups. 4.9.1 Function arguments: expression_matrix: A numeric matrix representing the expression data, where rows are genes and columns are cells. The matrix should be appropriately preprocessed and filtered before using this function. cell_types_groups: A data frame specifying cell type annotations for each cell, including cell type labels and group information. cellTypeOrders: The order of cell types for visualization. If not provided, the function will use the unique cell types in the input cell_types_groups. 4.9.2 codes for step8 Create a folder for saving the results of heterogeneity calculation. print(&#39;Step8. Calculate heterogeneity.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step8.Calculate_heterogeneity/&#39;))) { dir.create(paste0(output.dir, &#39;/Step8.Calculate_heterogeneity/&#39;)) } Run heterogeneity calculation process. expression_matrix &lt;- GetAssayData(object = datasets.before.batch.removal, slot = &quot;data&quot;)%&gt;%as.matrix() expression_matrix &lt;- expression_matrix[,rownames(sc_object@meta.data)] cell_types_groups &lt;- as.data.frame(cbind(sc_object@meta.data$selectLabels, sc_object@meta.data$datasetID)) colnames(cell_types_groups) &lt;- c(&#39;clusters&#39;, &#39;datasetID&#39;) if(is.null(ViolinPlot.cellTypeOrders)){ cellTypes_orders &lt;- unique(sc_object@meta.data$selectLabels) }else{ cellTypes_orders &lt;- ViolinPlot.cellTypeOrders } heterogeneity(expression_matrix = expression_matrix, cell_types_groups = cell_types_groups, cellTypeOrders = cellTypes_orders, output.dir = paste0(output.dir, &#39;/Step8.Calculate_heterogeneity/&#39;)) Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } Figure 4.20: Box plot showing the Spearman correlation coefficients between cells within the same cell type groups(here we take data including more samples as an example) 4.10 Step 9. Violin Plot for Marker Genes This step generates violin plots for marker genes across different cell types. 4.10.1 Function arguments: dataMatrix: A data frame or matrix representing the expression data, where rows are cells and columns are genes. features: A character vector specifying the marker genes to plot in the violin plots. CellTypes: A factor vector containing cell type annotations for each cell. cellTypeOrders: A character vector specifying the order of cell types for plotting. Defaults to unique values in CellTypes. cellTypeColors: A character vector specifying the colors to use for cell type groups. Defaults to a color palette. 4.10.2 codes for step9 Create a folder for saving the violin plots of marker genes. print(&#39;Step9. Violin plot for marker genes.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step9.Violin_plot_for_marker_genes/&#39;))) { dir.create(paste0(output.dir, &#39;/Step9.Violin_plot_for_marker_genes/&#39;)) } Run violin plot visualization. if( (length(input.data.dirs) &gt; 1) &amp; Step2_Quality_Control.RemoveBatches ){ DefaultAssay(sc_object) &lt;- &#39;integrated&#39; }else{ DefaultAssay(sc_object) &lt;- &#39;RNA&#39;} dataMatrix &lt;- GetAssayData(object = sc_object, slot = &quot;scale.data&quot;) if(is.null(marker.genes)&amp;(Org == &#39;mmu&#39;)){ # mpp genes are from &#39;The bone marrow microenvironment at single cell resolution&#39; # the other genes are from &#39;single cell characterization of haematopoietic progenitors and their trajectories in homeostasis and perturbed haematopoiesis&#39; # the aliases of these genes were changed in gecodeM16：Gpr64 -&gt; Adgrg2, Sdpr -&gt; Cavin2, Hbb-b1 -&gt; Hbb-bs, Sfpi1 -&gt; Spi1 HSC_lineage_signatures &lt;- c(&#39;Slamf1&#39;, &#39;Itga2b&#39;, &#39;Kit&#39;, &#39;Ly6a&#39;, &#39;Bmi1&#39;, &#39;Gata2&#39;, &#39;Hlf&#39;, &#39;Meis1&#39;, &#39;Mpl&#39;, &#39;Mcl1&#39;, &#39;Gfi1&#39;, &#39;Gfi1b&#39;, &#39;Hoxb5&#39;) Mpp_genes &lt;- c(&#39;Mki67&#39;, &#39;Mpo&#39;, &#39;Elane&#39;, &#39;Ctsg&#39;, &#39;Calr&#39;) Erythroid_lineage_signatures &lt;- c(&#39;Klf1&#39;, &#39;Gata1&#39;, &#39;Mpl&#39;, &#39;Epor&#39;, &#39;Vwf&#39;, &#39;Zfpm1&#39;, &#39;Fhl1&#39;, &#39;Adgrg2&#39;, &#39;Cavin2&#39;,&#39;Gypa&#39;, &#39;Tfrc&#39;, &#39;Hbb-bs&#39;, &#39;Hbb-y&#39;) Lymphoid_lineage_signatures &lt;- c(&#39;Tcf3&#39;, &#39;Ikzf1&#39;, &#39;Notch1&#39;, &#39;Flt3&#39;, &#39;Dntt&#39;, &#39;Btg2&#39;, &#39;Tcf7&#39;, &#39;Rag1&#39;, &#39;Ptprc&#39;, &#39;Ly6a&#39;, &#39;Blnk&#39;) Myeloid_lineage_signatures &lt;- c(&#39;Gfi1&#39;, &#39;Spi1&#39;, &#39;Mpo&#39;, &#39;Csf2rb&#39;, &#39;Csf1r&#39;, &#39;Gfi1b&#39;, &#39;Hk3&#39;, &#39;Csf2ra&#39;, &#39;Csf3r&#39;, &#39;Sp1&#39;, &#39;Fcgr3&#39;) marker.genes &lt;- c(HSC_lineage_signatures, Mpp_genes, Erythroid_lineage_signatures, Lymphoid_lineage_signatures, Myeloid_lineage_signatures) }else if(is.null(marker.genes)&amp;(Org == &#39;hsa&#39;)){ HSPCs_lineage_signatures &lt;- c(&#39;CD34&#39;,&#39;KIT&#39;,&#39;AVP&#39;,&#39;FLT3&#39;,&#39;MME&#39;,&#39;CD7&#39;,&#39;CD38&#39;,&#39;CSF1R&#39;,&#39;FCGR1A&#39;,&#39;MPO&#39;,&#39;ELANE&#39;,&#39;IL3RA&#39;) Myeloids_lineage_signatures &lt;- c(&#39;LYZ&#39;,&#39;CD36&#39;,&#39;MPO&#39;,&#39;FCGR1A&#39;,&#39;CD4&#39;,&#39;CD14&#39;,&#39;CD300E&#39;,&#39;ITGAX&#39;,&#39;FCGR3A&#39;,&#39;FLT3&#39;,&#39;AXL&#39;, &#39;SIGLEC6&#39;,&#39;CLEC4C&#39;,&#39;IRF4&#39;,&#39;LILRA4&#39;,&#39;IL3RA&#39;,&#39;IRF8&#39;,&#39;IRF7&#39;,&#39;XCR1&#39;,&#39;CD1C&#39;,&#39;THBD&#39;, &#39;MRC1&#39;,&#39;CD34&#39;,&#39;KIT&#39;,&#39;ITGA2B&#39;,&#39;PF4&#39;,&#39;CD9&#39;,&#39;ENG&#39;,&#39;KLF&#39;,&#39;TFRC&#39;) B_cells_lineage_signatures &lt;- c(&#39;CD79A&#39;,&#39;IGLL1&#39;,&#39;RAG1&#39;,&#39;RAG2&#39;,&#39;VPREB1&#39;,&#39;MME&#39;,&#39;IL7R&#39;,&#39;DNTT&#39;,&#39;MKI67&#39;,&#39;PCNA&#39;,&#39;TCL1A&#39;,&#39;MS4A1&#39;,&#39;IGHD&#39;,&#39;CD27&#39;,&#39;IGHG3&#39;) T_NK_cells_lineage_signatures &lt;- c(&#39;CD3D&#39;,&#39;CD3E&#39;,&#39;CD8A&#39;,&#39;CCR7&#39;,&#39;IL7R&#39;,&#39;SELL&#39;,&#39;KLRG1&#39;,&#39;CD27&#39;,&#39;GNLY&#39;, &#39;NKG7&#39;,&#39;PDCD1&#39;,&#39;TNFRSF9&#39;,&#39;LAG3&#39;,&#39;CD160&#39;,&#39;CD4&#39;,&#39;CD40LG&#39;,&#39;IL2RA&#39;, &#39;FOXP3&#39;,&#39;DUSP4&#39;,&#39;IL2RB&#39;,&#39;KLRF1&#39;,&#39;FCGR3A&#39;,&#39;NCAM1&#39;,&#39;XCL1&#39;,&#39;MKI67&#39;,&#39;PCNA&#39;,&#39;KLRF&#39;) marker.genes &lt;- c(HSPCs_lineage_signatures, Myeloids_lineage_signatures, B_cells_lineage_signatures, T_NK_cells_lineage_signatures) } if(is.null(ViolinPlot.cellTypeOrders)){ ViolinPlot.cellTypeOrders &lt;- unique(sc_object@meta.data$selectLabels) } if(is.null(ViolinPlot.cellTypeColors)){ ViolinPlot.cellTypeColors &lt;- viridis::viridis(length(unique(sc_object@meta.data$selectLabels))) } combinedViolinPlot(dataMatrix = dataMatrix, features = marker.genes, CellTypes = sc_object@meta.data$selectLabels, cellTypeOrders = ViolinPlot.cellTypeOrders, cellTypeColors = ViolinPlot.cellTypeColors, Org = Org, output.dir = paste0(output.dir, &#39;/Step9.Violin_plot_for_marker_genes/&#39;), databasePath = databasePath) Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } Figure 4.21: Violin plot showing the expression of marker genes between cell type groups 4.11 Step 10. Calculate Lineage Scores This step calculates lineage scores for specified gene sets based on the provided expression data. It then generates a heatmap of lineage scores and a heatmap of gene expression patterns. 4.11.1 Function arguments: expression_matrix: A data frame or matrix representing the expression data, where rows are cells and columns are genes. cellTypes: A character vector specifying cell type annotations for each cell. e.g. c(“HSC”,“HSC”,“HSC”,“MPP1”,“MPP2”,“MPP2”,“MPP2” …) cellTypes_orders: A character vector specifying the order of cell types for plotting. e.g. c(“HSC”,“MPP1”,“MPP2”) cellTypes_colors: A character vector specifying the colors to use for cell type groups. e.g. c(“HSC” = ‘#006d2c’,“MPP1” = ‘#4292c6’,“MPP2”= ‘#810f7c’). groups: A character vector specifying groups or clusters within each cell type. groups_orders: A character vector specifying the order of groups or clusters for plotting. groups_colors: A character vector specifying the colors to use for group or cluster annotations. e.g. c(‘group1’=‘#d73027’,‘group2’=‘#2171b5’) lineage.genelist: A list of gene sets representing lineage markers. lineage.names: A character vector specifying the names of the lineages. 4.11.2 codes for step10 Create a folder for saving the results of lineage score calculation. print(&#39;Step10. Calculate lineage scores.&#39;) # we use normalized data here if (!file.exists(paste0(output.dir, &#39;/Step10.Calculate_lineage_scores/&#39;))) { dir.create(paste0(output.dir, &#39;/Step10.Calculate_lineage_scores/&#39;)) } Run lineage score calculation. if(is.null(lineage.genelist)&amp;is.null(lineage.names)&amp;(Org == &#39;mmu&#39;)){ lineage.genelist &lt;- c(list(HSC_lineage_signatures), list(Mpp_genes), list(Erythroid_lineage_signatures), list(Lymphoid_lineage_signatures), list(Myeloid_lineage_signatures)) lineage.names &lt;- c(&#39;HSC_lineage_signatures&#39;, &#39;Mpp_genes&#39;, &#39;Erythroid_lineage_signatures&#39;, &#39;Lymphoid_lineage_signatures&#39;, &#39;Myeloid_lineage_signatures&#39;) }else if(is.null(lineage.genelist)&amp;is.null(lineage.names)&amp;(Org == &#39;hsa&#39;)){ lineage.genelist &lt;- c(list(HSPCs_lineage_signatures), list(Myeloids_lineage_signatures), list(B_cells_lineage_signatures), list(T_NK_cells_lineage_signatures)) lineage.names &lt;- c(&#39;HSPCs_lineage_signatures&#39;, &#39;Myeloids_lineage_signatures&#39;, &#39;B_cells_lineage_signatures&#39;, &#39;T_NK_cells_lineage_signatures&#39;) } if(is.null(ViolinPlot.cellTypeOrders)){ cellTypes_orders &lt;- unique(sc_object@meta.data$selectLabels) }else{ cellTypes_orders &lt;- ViolinPlot.cellTypeOrders } lineageScores(expression_matrix = expression_matrix, cellTypes = sc_object@meta.data$selectLabels, cellTypes_orders = cellTypes_orders, cellTypes_colors = ViolinPlot.cellTypeColors, groups = sc_object@meta.data$datasetID, groups_orders = unique(sc_object@meta.data$datasetID), groups_colors = groups_colors, lineage.genelist = lineage.genelist, lineage.names = lineage.names, Org = Org, output.dir = paste0(output.dir, &#39;/Step10.Calculate_lineage_scores/&#39;), databasePath = databasePath) Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } Figure 4.22: Heatmap showing the expression of lineage genes for each cell Figure 4.23: Heatmap showing the score of lineage signatures for each cell 4.12 Step 11. GSVA This step runs GSVA analysis, which calculates enrichment scores for gene sets in each cell using the provided gene list. It also performs differential GSVA analysis between specified cell groups and generates heatmaps of the results. 4.12.1 Function arguments: sc_object: A Seurat object containing the single-cell RNA-seq data. GSVA.genelist: A list of gene sets for GSVA analysis. GSVA.cellTypes: A character vector specifying the cell types or labels for each cell. GSVA.cellTypes.orders: A character vector specifying the order of cell types for visualization. GSVA.cellGroups: A character vector specifying the cell groups or conditions for each cell. GSVA.identify.cellType.features: Logical. If TRUE, identify cell type-specific features. GSVA.identify.diff.features: Logical. If TRUE, identify differentially expressed features between cell groups. GSVA.comparison.design: A list specifying the experimental design for differential GSVA analysis. OrgDB: An organism-specific annotation database (OrgDb) for gene symbol conversion. e.g. org.Mm.eg.db or org.Hs.eg.db. 4.12.2 codes for running step11 Create a folder for saving the results of GSVA. print(&#39;Step11. GSVA.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step11.GSVA/&#39;))) { dir.create(paste0(output.dir, &#39;/Step11.GSVA/&#39;)) } Run GSVA. setwd(wdir) if(Org==&#39;mmu&#39;){ load(paste0(databasePath,&quot;/mouse_c2_v5p2.rdata&quot;)) GSVA.genelist &lt;- Mm.c2 assign(&#39;OrgDB&#39;, org.Mm.eg.db) }else if(Org==&#39;hsa&#39;){ load(paste0(databasePath,&quot;/human_c2_v5p2.rdata&quot;)) GSVA.genelist &lt;- Hs.c2 assign(&#39;OrgDB&#39;, org.Hs.eg.db) }else{ stop(&quot;Org should be &#39;mmu&#39; or &#39;hsa&#39;.&quot;) } if(is.null(ViolinPlot.cellTypeOrders)){ cellTypes_orders &lt;- unique(sc_object@meta.data$selectLabels) }else{ cellTypes_orders &lt;- ViolinPlot.cellTypeOrders } run_GSVA(sc_object = sc_object, GSVA.genelist = GSVA.genelist, GSVA.cellTypes = sc_object@meta.data$selectLabels, GSVA.cellTypes.orders = cellTypes_orders, GSVA.cellGroups = sc_object@meta.data$datasetID, GSVA.identify.cellType.features = Step11_GSVA.identify.cellType.features, GSVA.identify.diff.features = Step11_GSVA.identify.diff.features, GSVA.comparison.design = Step11_GSVA.comparison.design, OrgDB = OrgDB, output.dir = paste0(output.dir, &#39;/Step11.GSVA/&#39;)) Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } Figure 4.24: GSVA Heatmap showing the enriched pathways of each cell type group 4.13 Step 12. Construct Trajectories In this step, users are allowed to construct trajectories using three methods including Monocle2, slingshot and scVelo. 4.13.1 data preparation Load gene symbols and ensemble IDs. DefaultAssay(sc_object) &lt;- &#39;RNA&#39; countsSlot &lt;- GetAssayData(object = sc_object, slot = &quot;counts&quot;) gene_metadata &lt;- as.data.frame(rownames(countsSlot)) rownames(gene_metadata) &lt;- gene_metadata[,1] if(Org == &#39;mmu&#39;){ load(paste0(databasePath,&quot;/mouseGeneSymbolandEnsembleID.rdata&quot;)) gene_metadata $ ensembleID &lt;- mapvalues(x = gene_metadata[,1], from = mouseGeneSymbolandEnsembleID$geneName, to = mouseGeneSymbolandEnsembleID$ensemblIDNoDot, warn_missing = FALSE) }else if(Org == &#39;hsa&#39;){ load(paste0(databasePath,&quot;/humanGeneSymbolandEnsembleID.rdata&quot;)) gene_metadata $ ensembleID &lt;- mapvalues(x = gene_metadata[,1], from = humanGeneSymbolandEnsembleID$geneName, to = humanGeneSymbolandEnsembleID$ensemblIDNoDot, warn_missing = FALSE) } colnames(gene_metadata) &lt;- c(&#39;gene_short_name&#39;,&#39;ensembleID&#39;) Create folders for saving the results of trajectory construction. print(&#39;Step12. Construct trajectories.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step12.Construct_trajectories/&#39;))) { dir.create(paste0(output.dir, &#39;/Step12.Construct_trajectories/&#39;)) } if (!file.exists(paste0(output.dir, &#39;/Step12.Construct_trajectories/monocle2/&#39;))) { dir.create(paste0(output.dir, &#39;/Step12.Construct_trajectories/monocle2/&#39;)) } if (!file.exists(paste0(output.dir, &#39;/Step12.Construct_trajectories/slingshot/&#39;))) { dir.create(paste0(output.dir, &#39;/Step12.Construct_trajectories/slingshot/&#39;)) } if (!file.exists(paste0(output.dir, &#39;/Step12.Construct_trajectories/scVelo/&#39;))) { dir.create(paste0(output.dir, &#39;/Step12.Construct_trajectories/scVelo/&#39;)) } Prepare the input data. if(is.null(Step12_Construct_Trajectories.clusters)){ sc_object.subset &lt;- sc_object countsSlot.subset &lt;- GetAssayData(object = sc_object.subset, slot = &quot;counts&quot;) }else{ sc_object.subset &lt;- subset(sc_object, subset = selectLabels %in% Step12_Construct_Trajectories.clusters) countsSlot.subset &lt;- GetAssayData(object = sc_object.subset, slot = &quot;counts&quot;) } 4.13.2 monocle2 Running monocle2 involves several steps: Creating a Monocle cellDataSet using the provided cellData, phenoData, and featureData. Estimating size factors, dispersions, and detecting highly variable genes. Performing differential gene expression analysis to identify genes associated with cell state changes. Ordering cells along the inferred trajectories and reducing dimensionality. Generating and saving trajectory plots, including cell trajectory by “State” and by “Cell Types.” 4.13.2.1 Function arguments: cellData: A matrix of gene expression values, where columns represent cells and rows represent genes. phenoData: A data frame containing cell metadata, such as cell labels or other relevant information. featureData: A data frame containing information about features (genes) in the dataset. lowerDetectionLimit: The lower detection limit for gene expression. Genes with expression values below this limit will be treated as non-detected. expressionFamily: The family of the expression distribution used in Monocle analysis. cellTypes: A character vector specifying cell types or labels used for coloring in trajectory plots. monocle.orders: A character vector specifying the order of cell types in the Monocle analysis. monocle.colors: A character vector specifying colors for cell types in trajectory plots. 4.13.2.2 codes for running monocle2 phenoData &lt;- sc_object.subset@meta.data featureData &lt;- gene_metadata run_monocle(cellData = countsSlot.subset, phenoData = phenoData, featureData = featureData, lowerDetectionLimit = 0.5, expressionFamily = VGAM::negbinomial.size(), cellTypes=&#39;selectLabels&#39;, monocle.orders=Step12_Construct_Trajectories.clusters, monocle.colors = ViolinPlot.cellTypeColors, output.dir = paste0(output.dir, &#39;/Step12.Construct_trajectories/monocle2/&#39;)) Figure 4.25: Figures showing cells in different trajectory states (left) and corresponding cell type groups (right) 4.13.3 Slingshot Running Slingshot to infer cell trajectories and lineage relationships involves several steps: Constructs a Slingshot object using PCA embeddings, cell types, start clusters, and end clusters. Computes and plots the trajectory curves. Computes and plots pseudotime values along the trajectory. 4.13.3.1 Function arguments: slingshot.PCAembeddings: A matrix containing the PCA embeddings of the single-cell data, typically obtained from dimensionality reduction techniques like PCA. slingshot.cellTypes: A character vector specifying cell types or labels for each cell. slingshot.start.clus: A character vector specifying the initial cluster(s) from which cell trajectories should start. slingshot.end.clus: A character vector specifying the target cluster(s) where cell trajectories should end. slingshot.colors: A vector of colors corresponding to cell types for plotting. If not provided, default colors will be used. 4.13.3.2 codes for running Slingshot if( (length(input.data.dirs) &gt; 1) &amp; Step2_Quality_Control.RemoveBatches ){ DefaultAssay(sc_object.subset) &lt;- &#39;integrated&#39; }else{ DefaultAssay(sc_object.subset) &lt;- &#39;RNA&#39;} run_slingshot(slingshot.PCAembeddings = Embeddings(sc_object.subset, reduction = &quot;pca&quot;)[, PCs], slingshot.cellTypes = sc_object.subset@meta.data$selectLabels, slingshot.start.clus = slingshot.start.clus, slingshot.end.clus = slingshot.end.clus, slingshot.colors = slingshot.colors, output.dir = paste0(output.dir, &#39;/Step12.Construct_trajectories/slingshot/&#39;)) Figure 4.26: Figures showing slingshot curve and infered pseudotime value 4.13.4 scVelo scVelo is implemented in Python, and it takes a Seurat object, cell embeddings, and cell type information as input. The process of data preparation includes the following steps: Format the Seurat object metadata, including cell types and sample names. Extract the spliced, unspliced, and ambiguous count matrices from the Seurat object. Combine the metadata and cell embeddings. Write the necessary input files for scVelo analysis, including cell embeddings, count matrices, and metadata. 4.13.4.1 Function arguments: sc_object: A Seurat object containing the single-cell RNA-seq data. loom.files.path: A character vector specifying the path(s) to the loom files for scVelo analysis. scvelo.reduction: A character specifying the reduction method used for scVelo analysis (default is ‘pca’). scvelo.column: A character specifying the column in the Seurat object metadata containing cell types. 4.13.4.2 codes for running Scvelo if((!is.null(loom.files.path))&amp;(!is.null(pythonPath))){ prepareDataForScvelo(sc_object = sc_object.subset, loom.files.path = loom.files.path, scvelo.reduction = &#39;pca&#39;, scvelo.column = &#39;selectLabels&#39;, output.dir = paste0(output.dir, &#39;/Step12.Construct_trajectories/scVelo/&#39;)) reticulate::py_run_string(paste0(&quot;import os\\noutputDir = &#39;&quot;, output.dir, &quot;&#39;&quot;)) reticulate::py_run_file(file.path(system.file(package = &quot;HemaScopeR&quot;), &quot;python/sc_run_scvelo.py&quot;), convert = FALSE) } Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } Figure 4.27: Figure showing trajectory predicted by scvelo 4.14 Step 13. TF Analysis This step runs SCENIC (Single-Cell Regulatory Network Inference and Clustering) analysis, including the construction of a co-expression network, gene filtering, correlation, and the GENIE3 algorithm to infer regulatory networks. 4.14.1 Function arguments: countMatrix: A matrix containing the raw counts of the single-cell RNA-seq data. cellTypes: A character vector specifying the cell types or labels for each cell. datasetID: A character vector specifying the dataset IDs for each cell. cellTypes_colors: A named vector of colors for cell type visualization. cellTypes_orders: A character vector specifying the desired order of cell types. groups_colors: A named vector of colors for grouping visualization. groups_orders: A character vector specifying the desired order of groups. Org: A character vector specifying the organism (‘mmu’ for mouse or ‘hsa’ for human). 4.14.2 codes for running step13 Create folders for saving the results of TF analysis. print(&#39;Step13. TF analysis.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step13.TF_analysis/&#39;))) { dir.create(paste0(output.dir, &#39;/Step13.TF_analysis/&#39;)) } Run SCENIC to perform TF analysis. run_SCENIC(countMatrix = countsSlot, cellTypes = sc_object@meta.data$selectLabels, datasetID = sc_object@meta.data$datasetID, cellTypes_colors = Step13_TF_Analysis.cellTypes_colors, cellTypes_orders = unique(sc_object@meta.data$selectLabels), groups_colors = Step13_TF_Analysis.groups_colors, groups_orders = unique(sc_object@meta.data$datasetID), Org = Org, output.dir = paste0(output.dir, &#39;/Step13.TF_analysis/&#39;), pythonPath = pythonPath, databasePath = databasePath) Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } Figure 4.28: Heatmap showing predicted regulon activity for each cell Figure 4.29: Heatmap showing statistics of regulons 4.15 Step 14. Cell-Cell Interaction The step takes expression data, cluster labels, and other parameters to perform cell-cell communication analysis using the CellChat package. It includes the following steps: Data input and preprocessing. Initialization of a CellChat object. Set the ligand-receptor interaction database based on the specified organism. Preprocess the expression data for cell-cell communication analysis. Identify overexpressed genes and interactions. Project data based on protein-protein interaction networks. Inference of cell-cell communication network. Visualization of the communication network. Systems analysis of cell-cell communication network. 4.15.1 Function arguments: data.input: A matrix of expression data, where rows represent genes and columns represent cells. Row names should be in the format of gene symbols. labels: A vector of cluster labels for each cell, corresponding to the columns of data.input. cell.orders: A character vector specifying the order of cell types or clusters in the analysis. cell.colors: A character vector specifying colors for cell types or clusters in the analysis. sample.names: A vector of sample or cell names, corresponding to the columns of data.input. Org: A string indicating the organism used in the analysis. It should be either “mmu” (mouse) or “hsa” (human). sorting: A logical value indicating whether to consider cell population size in communication analysis. 4.15.2 codes for running step14 Create folders for saving the results of cell-cell interaction analysis. print(&#39;Step14. Cell-cell interaction.&#39;) if (!file.exists(paste0(output.dir, &#39;/Step14.Cell_cell_interection/&#39;))) { dir.create(paste0(output.dir, &#39;/Step14.Cell_cell_interection/&#39;)) } Run CellChat to perform cell-cell interaction analysis. tempwd &lt;- getwd() run_CellChat(data.input=countsSlot, labels = sc_object@meta.data$selectLabels, cell.orders = ViolinPlot.cellTypeOrders, cell.colors = ViolinPlot.cellTypeColors, sample.names = rownames(sc_object@meta.data), Org = Org, sorting = sorting, output.dir = paste0(output.dir, &#39;/Step14.Cell_cell_interection/&#39;)) setwd(tempwd) Save the variables. # Get the names of all variables in the current environment variable_names &lt;- ls() # Loop through the variable names and save them as RDS files for (var_name in variable_names) { var &lt;- get(var_name) # Get the variable by its name saveRDS(var, file = paste0(output.dir, &#39;/RDSfiles/&#39;, var_name, &quot;.rds&quot;)) # Save as RDS with the variable&#39;s name } Figure 4.30: Figures showing the interaction number and strength between each cell group Figure 4.31: Heatmap showing the strength of incoming and outgoing signals for each cell type group across various pathways. Figure 4.32: Figure showing LRs interaction between each cell type group "]]
